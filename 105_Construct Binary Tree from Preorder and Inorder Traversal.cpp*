/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 //memory limit exceeded!!
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return create(preorder, inorder, 0, preorder.size()-1 ,0 , inorder.size()-1);
    }
    
    TreeNode* create(vector<int> preorder, vector<int> inorder, int ps, int pe, int is, int ie)
    {
        if(is > ie) return NULL;
        int mid = 0;    
        for(int i = is; i <= ie; i++)
        {
            if(inorder[i] == preorder[ps])
            {
                mid = i;
                break;
            }    
        }
        
        TreeNode* root = new TreeNode(preorder[ps]);
        root->left = create(preorder, inorder, ps+1, ps+mid-is, is, mid - 1);
        root->right = create(preorder, inorder, ps+mid-is+1, pe, mid+1 ,ie);
            
        return root;
        
    }
};

//iterative algorithms
class Solution {
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
        
        if(preorder.size()==0)
            return NULL;
        
        stack<int> s;
        stack<TreeNode *> st;
        TreeNode *t,*r,*root;
        int i,j,f;
        
        f=i=j=0;
        s.push(preorder[i]);
        
        root = new TreeNode(preorder[i]);
        st.push(root);
        t = root;
        i++;
        
        while(i<preorder.size())
        {
            if(!st.empty() && st.top()->val==inorder[j])
            {
                t = st.top();
                st.pop();
                s.pop();
                f = 1;
                j++;
            }
            else
            {
                if(f==0)
                {
                    s.push(preorder[i]);
                    t -> left = new TreeNode(preorder[i]);
                    t = t -> left;
                    st.push(t);
                    i++;
                }
                else 
                {
                    f = 0;
                    s.push(preorder[i]);
                    t -> right = new TreeNode(preorder[i]);
                    t = t -> right;
                    st.push(t);
                    i++;
                }
            }
        }
        
        return root;
    }
};
